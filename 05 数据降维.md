这里降维中维度指的是特征数量，而不是数组中的维度

数据降维的两种方式：特征选择和主成分分析

# 特征选择

特征选择应用场景：

1.冗余：部分特征的相关度高，容易消耗计算机性能

2.噪声：部分特征对预测结果有影响

主要方法：1.过滤式(`Filter`):`Variance Threshold` 2.嵌入式`(Embeddwed`):正则化、决策树 3.包裹式(`Wrapper`)

其他方法：神经网络

## 过滤式(`Filter`):`Variance Threshold`

 `Variance `含义是方差，特别地，当方差为零时，特征的每一个数据都一样，而过滤式这种方式就是按照一定的方差范围选择特征。

`sklearn`特征选择API：`sklearn.feature_selection.VarianceThreshold`

语法：1.删除所有低方差特征`VarianceThreshold(threshold=0.0)`

2.`VarianceThreshold(X)`

X:`numpy array`格式的数据，返回值是训练集差异低于`threshold`的特征将被删除，默认是保留所有非零方差特征，即删除所有样本中具有相同值的特征

代码：

```python
from sklearn.feature_selection import VarianceThreshold
#导入特征降维过滤式处理类
def var():
    """
    特征选择-删除低方差特征：
    ：return:None
    """
    var= VarianceThreshold(threshold=0.0)
    # 实例化,指定阈值方差
    data=var.fit_transform([[5,8,9],[5,7,3],[5,4,6]])
    # 传入数组数据，调用fit_transform处理实例化后的数组
    print(data)
    # 打印删除低方差特征后的数组
    return None
if __name__=="__main__":
       var()
```

运行结果：

```python
[[8 9]
 [7 3]
 [4 6]]
```

# 主成分分析

`sklearn`主成分分析API：`sklearn.decomposition`

### PCA(特征数量达到几百以上可考虑使用其进行数据简化)

本质：PCA是一种分析、简化数据集的技术

目的：是数据维数压缩，尽可能降低原数据的维数(复杂度),损失少量信息

作用：可以削减回归分析或者聚类分析中特征的数量

**注**:不止是特征发生变化，数据也会发生变化

高纬度数据容易出现特征之间相关的问题，所以就可以将高维度的数据转化为低维度的数据

*公式：Y=PX(矩阵运算)，P为原特征数据，X为降低维度后的数据*

`PCA`语法：

1.`PCA(n_components=None)`将数据分解为较低维度空间

`n_components`有两种类型：小数(0~1,90%~100%常见，常用的是90%~95%)和整数(指定减少到的特征数量，一般不使用)

2.`PCA.fit_transform(X)` 

X:`numpy array`格式的数据  返回值是转换后指定维度的array

代码：

```python
from sklearn.decomposition import PCA
#导入特征降维主成分分析处理类
def pca():
    """
    主成分分析进行特征降维：
    ：return:None
    """
    pca= PCA(n_components=0.9)
    # 实例化,指定特征保留比例
    data=pca.fit_transform([[5,8,9],[6,7,3],[5,4,6]])
    # 传入数组数据，调用fit_transform处理实例化后的数组
    print(data)
    # 打印PCA主成分分析处理后的数组
    return None
if __name__=="__main__":
       pca()
```

运行结果：

```python
[[ 3.3464337  -0.83082512]
 [-2.78593279 -1.45858404]
 [-0.56050091  2.28940916]]
```

# 案例分析

**分析每个用户的购买能力**

两张`csv(utf8)`格式的数据表：

`goods.csv`

| goods      | order | price |
| ---------- | ----- | ----- |
| 华为手机   | 1-001 | 4000  |
| 苹果手机   | 2-001 | 6000  |
| 苹果笔记本 | 2-003 | 12000 |
| vivo手机   | 3-001 | 2700  |
| 三星手机   | 4-001 | 3500  |
| 联想笔记本 | 5-003 | 6600  |
| 华为平板   | 1-002 | 3000  |
| 苹果平板   | 2-002 | 2800  |
| 微软笔记本 | 6-003 | 11000 |
| 小米手机   | 7-001 | 1500  |
| 微软平板   | 6-002 | 8000  |
| 小米笔记本 | 7-003 | 4500  |

`customers.csv`

| customers | order |
| --------- | ----- |
| 1         | 2-001 |
| 2         | 1-001 |
| 3         | 3-001 |
| 5         | 1-002 |
| 4         | 4-001 |
| 3         | 2-002 |
| 2         | 5-003 |
| 6         | 7-001 |
| 1         | 6-003 |
| 6         | 7-003 |
| 4         | 2-003 |
| 1         | 6-002 |

代码：

```python
import pandas as pd
#导入pandas处理表
from sklearn.decomposition import PCA
#导入特征降维主成分分析处理类
def pca():
    """
    主成分分析进行特征降维：
    ：return:None
    """
    customers=pd.read_csv("customers.csv")
    goods=pd.read_csv("goods.csv")
    #读取两张表
    c_g=pd.merge(customers,goods,on=['order','order'])
    #合并两张表，并以两张表的order字段为联系
    print(c_g.head(10))
    #打印数据表的前十行数据
    crosstable=pd.crosstab(c_g['customers'],c_g['goods'])
    #建立交叉表，前者为行，后者为列，即后者为特征，前者为样本
    print(crosstable)
    #打印交叉表
    pca= PCA(n_components=0.9)
    # 实例化,指定特征保留比例
    data=pca.fit_transform(crosstable)
    # 传入数组数据(数据表本身具有行和列，也可以传入)，调用fit_transform处理实例化后的数组
    print(data,data.shape)
    # 打印PCA主成分分析处理后的数组及其形状
    return None
if __name__=="__main__":
       pca()
```

运行结果：

```python
customers  order   goods  price
0          1  2-001    苹果手机   6000
1          2  1-001    华为手机   4000
2          3  3-001  vivo手机   2700
3          5  1-002    华为平板   3000
4          4  4-001    三星手机   3500
5          3  2-002    苹果平板   2800
6          2  5-003   联想笔记本   6600
7          6  7-001    小米手机   1500
8          1  6-003   微软笔记本  11000
9          6  7-003   小米笔记本   4500
#合并后的表
goods      vivo手机  三星手机  华为平板  华为手机  小米手机  ...  微软笔记本  联想笔记本  苹果平板  苹果手机  苹果笔记本
customers                                  ...                                 
1               0     0     0     0     0  ...      1      0     0     1      0
2               0     0     0     1     0  ...      0      1     0     0      0
3               1     0     0     0     0  ...      0      0     1     0      0
4               0     1     0     0     0  ...      0      0     0     0      1
5               0     0     1     0     0  ...      0      0     0     0      0
6               0     0     0     0     1  ...      0      0     0     0      0

[6 rows x 12 columns]
#交叉处理后的表
[[ 1.52426053e+00 -5.62678659e-17  1.68803598e-16  7.50238213e-17
  -9.98157153e-02]
 [-3.42569736e-01 -1.16504848e-02  1.00911793e+00 -6.93934625e-01
  -2.22064501e-01]
 [-3.42569736e-01 -4.54435159e-01 -9.40491997e-01 -6.39502533e-01
  -2.22064501e-01]
 [-3.42569736e-01  1.15084864e+00 -2.52029574e-01  3.34706591e-01
  -2.22064501e-01]
 [-1.53981583e-01  4.79915122e-17 -4.56476612e-15  7.33944073e-17
   9.88073718e-01]
 [-3.42569736e-01 -6.84762996e-01  1.83403638e-01  9.98730567e-01
  -2.22064501e-01]]
#交叉表主成分分析后的结果
 (6, 5)
#交叉表的形状
```

**注**：

1.`pd.read_csv(path)`为`pandas`中读取`csv`文件的函数，路径既可以是绝对路径(注意使用'r'防止转义字符影响路径)，也可以是相对路径(注意放到当前project文件夹下，`path='./文件夹/xxx.csv'`)

2.`pd.merge(导入后的表一名字,导入后的表二名字,on=[''表一字段''，''表二字段''])`合并两张表，并以两张表的两个字段为联系，表一在前，表二在后；`pd.crosstab(导入后表名['字段名'],导入后表名['字段名'])`建立交叉表，前者为行，后者为列，即后者为特征，前者为样本

3.`导入数据表名.head(行数)`获取前n行数据，`导入数据表名.shape`获取数据表的形状（行数，列数）
